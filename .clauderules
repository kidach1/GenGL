# Claude-OpenGL 実装ルール

## このファイルについて
このファイルはAIアシスタント（Claude）のための実装指示書です。
人間向けのドキュメントは Context.md に記載されており、
このファイルには実装において厳守すべきルールを記載しています。

## ディレクトリ構成
- src/: ソースコード
  - main.cpp: エントリーポイント
  - renderer/: レンダリング関連コード
  - core/: コア機能
  - utils/: ユーティリティ関数
- include/: 公開ヘッダー
- assets/: アセット（シェーダー、テクスチャなど）
- libs/: 外部ライブラリ
- tests/: ユニットテスト
- build/: CMakeビルドディレクトリ

## コーディングスタイル
- インデント: 4スペース（タブ使用禁止）
- 行幅: 最大100文字
- 命名規則:
  - クラス: PascalCase（例: `Shader`, `Mesh`）
  - 関数/メソッド: camelCase（例: `createWindow`, `loadTexture`）
  - 変数: camelCase（例: `textureId`, `vertexBuffer`）
  - 定数/マクロ: UPPER_SNAKE_CASE（例: `MAX_LIGHTS`, `WINDOW_WIDTH`）
  - ファイル名: snake_case（例: `shader.cpp`, `texture_loader.h`）
- 中括弧: 開始中括弧はステートメントと同じ行に配置
  ```cpp
  if (condition) {
      // コード
  }
  ```
- ヘッダーガード: 従来のヘッダーガードの代わりに `#pragma once` を使用
- インクルード順序:
  1. 標準ライブラリヘッダー（例: `<vector>`, `<string>`）
  2. 外部ライブラリヘッダー（例: `<glad/gl.h>`, `<GLFW/glfw3.h>`）
  3. プロジェクトヘッダー（例: `"renderer/shader.h"`）

## ドキュメント
- クラス、関数、メンバー変数にはDoxygen形式のコメントを使用
- 例:
  ```cpp
  /**
   * @brief 頂点シェーダーとフラグメントシェーダーからシェーダープログラムをロード・コンパイル
   * @param vertexPath 頂点シェーダーファイルへのパス
   * @param fragmentPath フラグメントシェーダーファイルへのパス
   * @return シェーダープログラムIDまたはコンパイル失敗時は0
   */
  unsigned int loadShader(const std::string& vertexPath, const std::string& fragmentPath);
  ```

## エラー処理
- 例外的な状況には例外を使用
- 予想されるエラー条件には戻り値を使用
- デバッグビルドでは常にOpenGLエラーをチェック
- OpenGLエラーチェックを行う場所と頻度：
  - 各OpenGL関数呼び出し後は重いため、開発初期段階では各関数セクションの終了時にのみチェック
  - リリースビルドでは無効化することを想定

## メモリ管理
- 生ポインタよりもスマートポインタ(`std::unique_ptr`, `std::shared_ptr`)を優先
- すべてのリソース管理にはRAII原則に従うこと
  - リソースの確保はコンストラクタで行う
  - リソースの解放はデストラクタで行う
  - リソースをクラスのメンバ変数としてカプセル化する
  - リソースの移動セマンティクスを適切に実装する
- OpenGLリソース（バッファ、テクスチャ、シェーダーなど）は必ずデストラクタで解放

## OpenGL固有のルール
- OpenGLコンテキストが有効な状態でのみOpenGL関数を呼び出す
- VAOをバインドしてからVBO/EBOを設定する
- シェーダーをuse()してからuniformを設定する
- テクスチャはbind()してから使用し、使用後はunbind()する
- OpenGLリソースのIDは0で初期化し、IDが0でない場合のみ削除処理を行う
- 深度テストやブレンディングなどの状態変更は必要な時だけ行い、使用後は元の状態に戻す
- RAII原則を特に重視し、OpenGLリソースをカプセル化するクラス（Shader、Mesh、Textureなど）を作成する

## ビルドシステム
- プロジェクト設定にはCMakeを使用
- 最小要求CMakeバージョン: 3.10
- C++17標準をターゲット
- マルチプラットフォーム対応のため、条件付きコンパイルを適切に使用

## マルチプラットフォーム対応
- プラットフォーム依存コードは条件付きコンパイルで分離
  ```cpp
  #if defined(_WIN32)
      // Windows固有の実装
  #elif defined(__APPLE__)
      // macOS固有の実装
  #else
      // Linux固有の実装
  #endif
  ```
- ファイルパスはプラットフォーム非依存にするため、std::filesystemを使用
- 外部ライブラリの依存関係はCMakeでプラットフォームごとに適切に設定
- Windows、Linux、macOSで同一の動作を保証できるようにする

## 設計原則
- 設計は再帰的に検討し、定期的に精度を向上させる
- 単一責任の原則（SRP）に従い、各クラスは単一の責任を持つ
- 依存性の逆転原則を適用し、上位モジュールは下位モジュールに依存しない
- プログラム対インターフェイスの原則を守り、具体的な実装ではなくインターフェイスに依存する
- 拡張性を考慮した設計を心掛ける
- パフォーマンスクリティカルな部分では最適化を検討するが、早すぎる最適化は避ける

## 例外と実装の注意点
- 開発初期段階では、レンダリングコードをApplicationクラスに直接記述することを許容するが、最終的にはRenderer専用クラスに移行する
- 一時的なコードを記述する場合は必ずTODOコメントを残し、将来の修正計画を記録する
- シェーダー読み込みエラーは詳細なデバッグ情報を出力し、開発者がシェーダーの問題を特定しやすくする
- ルールに従えない場合や例外的な実装を行う場合は、必ずユーザーに通知し、その理由と将来の修正計画を説明する
- プラットフォーム固有の実装は適切にコメントし、他のプラットフォームとの互換性を考慮する

## Gitワークフロー
- 一つの実装が終わるたびにコミットを行う
- コミットメッセージは以下の形式に従う：
  ```
  [コンポーネント] 変更内容の要約

  - 詳細な変更点1
  - 詳細な変更点2（必要に応じて）
  ```
- 機能実装は個別のブランチで行い、完成後にメインブランチにマージする
- コミット前にコードの動作確認を行う

## 実装チェックリスト
各実装を完了する前に以下の項目を確認する：
- [ ] コードスタイルがルールに準拠しているか
- [ ] 適切なエラー処理が実装されているか
- [ ] OpenGLリソースが適切に管理されているか
- [ ] メモリリークがないか
- [ ] パフォーマンス上の問題がないか
- [ ] 設計原則に従っているか
- [ ] マルチプラットフォーム対応が適切に行われているか
- [ ] ルールに従えない例外がある場合、ユーザーに通知したか

## プロジェクトアーキテクチャ
プロジェクトは以下の主要コンポーネントで構成される：

1. **コアシステム**: アプリケーション全体を管理
2. **ウィンドウ管理**: GLFWを使用したウィンドウ操作
3. **入力管理**: キーボード、マウス入力の処理
4. **レンダリングシステム**: OpenGLレンダリングパイプライン管理
5. **リソース管理**: アセットの読み込みと管理
6. **カメラシステム**: 3D空間でのカメラ操作
7. **ユーティリティ**: ログ記録、パフォーマンスモニタリング、プラットフォーム互換性など

## 実装段階
1. **基盤セットアップ**（Window, Application, Shader）
2. **基本レンダリング**（Mesh, Texture, 三角形描画）
3. **カメラと入力管理**（Camera, InputManager）
4. **リソース管理**（ResourceManager, Model）
5. **高度な機能**（光源、影、ポストプロセス）
6. **マルチプラットフォーム対応**（Windows, Linux, macOS対応）

各段階で、完了したら必ず `Context.md` を更新し、進捗と発生した問題、その解決策を記録すること。